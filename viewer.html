<!DOCTYPE html> <meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>360度パノラマ画像ライブラリ</title>
<link rel="stylesheet" href="pannellum.css" />
<script>
  if (!('DeviceMotionEvent' in globalThis)) {
    globalThis.DeviceMotionEvent = {};
  }
</script>
<style>
  * {
    margin: 0;
    padding: 0;
    font: inherit;
    color: inherit;
    appearance: none;
    background-color: transparent;
    background-repeat: no-repeat;
    background-position: center;
    border-style: none;
    border-color: currentColor;
    border-width: 1px;
    border-radius: 0;
    stroke-linejoin: round;
    stroke-linecap: round;
    stroke-width: 1px;
    fill: none;
  }
  button {
    cursor: pointer;
  }
  :root {
    --footer-baseline: 6px;
    --border-radius: 5px;
    --ui-background: rgba(0, 0, 0, 0.4);
    --font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN',
      'Hiragino Sans', 'BIZ UDPGothic', Meiryo, sans-serif;
    height: 100%;
  }
  body {
    position: fixed;
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: var(--font-family);
    font-size: 14px;
  }
  .pnlm-container {
    font-family: var(--font-family);
  }
  .pnlm-container[data-show-markers='0'] .pnlm-hotspot {
    opacity: 0;
    pointer-events: none;
  }
  .pnlm-hotspot {
    display: grid;
    align-content: center;
    justify-content: center;
    cursor: pointer;
  }
  .pnlm-title-box {
    font-size: inherit;
    margin-bottom: 0;
  }
  .pnlm-container[data-vertical-markers='1'] .hotspot-tooltip {
    writing-mode: vertical-rl;
  }
  .hotspot-tooltip {
    position: absolute;
    bottom: 50%;
    left: 50%;
    transform: translateX(-50%);
    inline-size: max-content;
    max-inline-size: 183px;
    padding-inline: 6px;
    padding-block: 2px;
    color: #ffffff;
  }
  .hotspot-marker {
    position: absolute;
    filter: drop-shadow(0 0 2px #000000);
  }
  .hotspot-marker > path {
    /* fill: var(--ui-background); */
    fill: currentColor;
    stroke: currentColor;
    pointer-events: none;
  }
  .pnlm-hotspot > .hotspot-marker {
    bottom: 50%;
    left: 50%;
    transform: translateX(-50%);
  }
  .hotspot-marker-backdrop {
    display: none;
    position: absolute;
  }
  .hotspot-marker-backdrop,
  .pnlm-panorama-info,
  .app-settings {
    backdrop-filter: blur(2px);
  }
  .coordinate-text,
  .hotspot-tooltip,
  .pnlm-panorama-info,
  .app-settings {
    text-shadow: 0 0 4px #000000;
  }
  .coordinate {
    z-index: 1;
    position: absolute;
    left: 50%;
    bottom: 50%;
    transform: translateX(-50%);
    display: grid;
    grid-auto-flow: row;
    row-gap: 2px;
    justify-items: center;
  }
  .coordinate > .hotspot-marker {
    bottom: 0;
  }
  .coordinate > button {
    position: absolute;
    bottom: 0;
    padding: 2px 6px;
    background: none;
    border: none;
    color: inherit;
    font: inherit;
    cursor: pointer;
    white-space: nowrap;
  }
  .pnlm-panorama-info,
  .app-settings,
  .pnlm-hotspot,
  .coordinate {
    color: #ffffff;
    font-size: inherit;
    font-weight: 600;
  }
  .pnlm-panorama-info,
  .app-settings {
    --gap: 4px;
    --padding-v: 8px;
    --padding-h: 11px;
    bottom: var(--footer-baseline);
    padding: var(--padding-v) var(--padding-h);
    /* border-style: solid; */
    background-color: var(--ui-background);
  }
  .pnlm-panorama-info {
    display: grid;
    grid-auto-flow: row;
    align-items: end;
    border-radius: 0 var(--border-radius) var(--border-radius) 0;
    border-left-width: 0;
  }
  .pnlm-panorama-info > * {
    padding: 0;
  }
  .app-settings {
    z-index: 1;
    position: absolute;
    right: 0;
    display: grid;
    grid-auto-flow: row;
    justify-content: end;
    justify-items: end;
    row-gap: var(--gap);
    max-width: 90%;
    border-radius: var(--border-radius) 0 0 var(--border-radius);
    border-right-width: 0;
  }
  .app-settings > #config-toggle {
    padding: var(--padding-v) var(--padding-h);
    margin: calc(-1 * var(--padding-v)) calc(-1 * var(--padding-h));
  }
  .app-options {
    display: grid;
    grid-template-columns: max-content 1fr;
    align-items: center;
    column-gap: var(--gap);
    row-gap: var(--gap);
    padding-block: var(--gap);
  }
  .app-settings > #config-toggle::before {
    content: '設定';
  }
  .app-settings.active > #config-toggle::before {
    content: '閉じる';
  }
  .app-settings.active + .pnlm-panorama-info {
    display: none;
  }
  .app-settings:not(.active) > section {
    display: none;
  }
  .app-options > input {
    appearance: auto;
  }
  .app-options > input:disabled,
  .app-options > input:disabled + label {
    opacity: 0.7;
    pointer-events: none;
  }
  .app-options > input:disabled + label {
    text-decoration: line-through;
  }
  .app-options > h1,
  .app-options > hr,
  .app-options > #export-json,
  .app-options > .zoom-slider {
    grid-column: 1 / 3;
  }
  .app-options > hr {
    margin-block: var(--gap);
    block-size: 1px;
    background-color: currentColor;
    opacity: 0.5;
  }
  #export-json {
    padding-inline: 8px;
    text-decoration: none;
  }
  #export-json:hover {
    text-decoration: underline;
  }
  .zoom-slider {
    display: grid;
    grid-template-columns: max-content 1fr max-content;
    align-items: center;
    column-gap: 6px;
    padding: 4px 0;
  }
  .zoom-slider > input {
    background-image: linear-gradient(currentColor, currentColor);
    background-size: 100% 1px;
  }
  .zoom-slider > svg {
    width: 16px;
    height: 16px;
    cursor: pointer;
  }
  .zoom-slider > svg > * {
    stroke: currentColor;
    stroke-width: 1.5px;
  }
  .marker-list {
    grid-column: 1 / 3;
    display: grid;
    grid-template-columns: max-content 1fr;
    row-gap: var(--gap);
    column-gap: var(--gap);
  }
  .marker-list > dd {
    max-inline-size: 20em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
  }
  .marker-list > dd:hover {
    text-decoration: underline;
  }
</style>
<div id="container">
  <noscript>
    <div class="pnlm-info-box">
      <p>パノラマ画像を表示にはJavaScriptを有効にしてください。</p>
      <p>Javascript is required to view this panorama.</p>
    </div>
  </noscript>
</div>
<script src="pannellum.js"></script>
<script>
  //@ts-check
  (async function () {
    const SVGNS = 'http://www.w3.org/2000/svg';
    const createElement = (tagName) => {
      switch (tagName) {
        case 'svg':
        case 'path':
        case 'circle':
        case 'rect':
          return document.createElementNS(SVGNS, tagName);
        default:
          return document.createElement(tagName);
      }
    };
    /** @typedef {Record<string, string | boolean>} Attrs */
    /** @typedef {[string, Attrs, Array<NodeDef | string>]} NodeDef */
    /**
     * @template {HTMLElement} T
     * @typedef {(parent: T) => Iterable<Node>} NodeGen
     */
    /**
     * @template {string} T
     * @template {HTMLElement} S
     * @param {T} tagName
     * @param {Attrs | null} attrs
     * @param {Array<NodeGen<S> | Node | string>} children
     * @returns {S}
     */
    const dom = (tagName, attrs = {}, ...children) => {
      const node = createElement(tagName);
      if (attrs) {
        for (const [name, value] of Object.entries(attrs)) {
          switch (name) {
            case 'checked':
            case 'disabled':
            case 'selected':
              node[name] = value;
              break;
            default:
              if (value || typeof value === 'number') {
                node.setAttribute(name, `${value}`);
              }
          }
        }
      }
      if (children) {
        for (const child of children) {
          if (typeof child === 'function') {
            node.append(...child(node));
          } else if (typeof child === 'string') {
            node.append(document.createTextNode(child));
          } else if (child instanceof Node) {
            node.append(child);
          }
        }
      }
      return node;
    };
    const createMarker = function* (wrappee) {
      const backdrop = dom('div', { class: 'hotspot-marker-backdrop' });
      yield backdrop;
      yield dom('svg', { class: 'hotspot-marker' }, function* (svg) {
        const lw = 1;
        const aw2 = 4;
        const ah = 6;
        const r = 4;
        const path = dom('path', { style: `stroke-width:${lw}px` });
        const observer = new ResizeObserver(([{ target }]) => {
          const rect = target.getBoundingClientRect();
          const pRect = target.parentElement?.getBoundingClientRect();
          if (pRect) {
            Object.assign(backdrop.style, {
              left: `${rect.left - pRect.left}px`,
              top: `${rect.top - pRect.top}px`,
              width: `${rect.width}px`,
              height: `${rect.height}px`,
            });
          }
          const w2 = rect.width / 2;
          const h = rect.height;
          {
            const ww = w2 * 2 + lw * 2;
            const hh = h + ah + lw * 2;
            svg.style.width = `${ww}px`;
            svg.style.height = `${hh}px`;
            const viewBox = `${ww / -2} ${-hh + ah + lw} ${ww} ${hh}`;
            svg.setAttribute('viewBox', viewBox);
          }
          const d = `M${-aw2} 0L0 ${ah}L${aw2} 0Z`;
          // let d = `M${-aw2} 0L0 ${ah}L${aw2} 0H${w2 - r}q${r} 0 ${r} ${-r}`;
          // d += `V${-h + r}q0 ${-r} ${-r} ${-r}H${-w2 + r}`;
          // d += `q${-r} 0 ${-r} ${r}V${-r}q0 ${r} ${r} ${r}Z`;
          path.setAttribute('d', d);
        });
        observer.observe(wrappee);
        wrappee.style.marginBottom = `${ah + lw / 2}px`;
        yield path;
      });
    };
    const loadConfig = async () => {
      const image = new URLSearchParams(location.search).get('image');
      const params = { panorama: `${image}.jpg`, config: `${image}.json` };
      const res = await fetch(params.config);
      if (!res.ok) {
        throw new Error(`The file ${params.config} could not be accessed.`);
      }
      return {
        ...params,
        ...(await res.json()),
        autoLoad: true,
        keyboardZoom: false,
        showControls: false,
        friction: 0.8,
      };
    };
    let viewer;
    const start = (config) => {
      if (viewer) {
        const oldConfig = viewer.getConfig();
        if (oldConfig.panorama.startsWith('blob:')) {
          URL.revokeObjectURL(oldConfig.panorama);
        }
        viewer.destroy();
        viewer = null;
      }
      const createTooltip = (markerDiv, marker) => {
        markerDiv.dataset.hotspot = marker.id;
        markerDiv.style.backgroundImage = 'none';
        const tooltip = dom('div', { class: 'hotspot-tooltip' }, marker.text);
        markerDiv.append(...createMarker(tooltip), tooltip);
        markerDiv.addEventListener('click', (event) => {
          focusMarker(marker.id);
        });
      };
      const getMarkers = () => (viewer.getConfig().hotSpots || []).slice();
      const syncMarkersList = () => {
        const container = viewer.getContainer();
        const listElement = container.querySelector('.marker-list');
        while (listElement.firstChild) {
          listElement.firstChild.remove();
        }
        const current = viewer.getConfig();
        const markers = getMarkers();
        markers.forEach((marker, index) => {
          const dd = dom('dd', null, marker.text);
          dd.addEventListener('click', () => focusMarker(marker.id));
          listElement.append(dom('dt', null, `(${index + 1})`), dd);
        });
        const a = container.querySelector('#export-json');
        if (a) {
          const { title, author } = current;
          const data = JSON.stringify(
            {
              title,
              author,
              hotSpots: markers.map(({ pitch, yaw, text }) => ({
                pitch,
                yaw,
                text,
              })),
            },
            null,
            2,
          );
          const BOM = new Uint8Array([0xef, 0xbb, 0xbf]);
          const blob = new Blob([BOM, data], { type: 'application/json' });
          URL.revokeObjectURL(a.href);
          a.href = URL.createObjectURL(blob);
          const name = isLocalFile ? title : current.panorama;
          a.setAttribute('download', name.replace(/(\.[^.]*?)?$/, '.json'));
        }
      };
      const setMarker = (newMarker) => {
        if (newMarker.id) {
          for (const marker of getMarkers()) {
            if (marker.id === newMarker.id) {
              viewer.removeHotSpot(marker.id);
            }
          }
        }
        if (newMarker.text) {
          viewer.addHotSpot({
            id: Date.now().toString(16),
            ...newMarker,
            createTooltipFunc: createTooltip,
            createTooltipArgs: newMarker,
          });
        }
        syncMarkersList();
      };
      /** @param {string} id */
      const focusMarker = (id) => {
        const marker = getMarkers().find((marker) => marker.id === id);
        const { pitch, yaw } = marker;
        if (marker) {
          const d = Math.hypot(
            yaw - viewer.getYaw(),
            pitch - viewer.getPitch(),
          );
          if (1e-3 < d) {
            location.hash = `#${marker.id}`;
            viewer.setYaw(yaw);
            viewer.setPitch(pitch);
            coordinateMonitor.track();
          } else {
            const newText = prompt(
              `(${yaw.toFixed(2)},${pitch.toFixed(
                2,
              )}) のマーカーのテキストを修正する（空にすると削除します）`,
              marker.text,
            );
            if (newText === null) {
              return;
            }
            if (newText === null) {
              return;
            }
            setMarker({ ...marker, text: newText });
          }
        }
      };
      const coordinateMonitor = (function () {
        const coordinateText = dom('button', {
          title: 'クリックでコピー',
          class: 'coordinate-text',
        });
        const sync = () => {
          const yaw = viewer.getYaw().toFixed(2);
          const pitch = viewer.getPitch().toFixed(2);
          coordinateText.textContent = `${yaw}, ${pitch}`;
        };
        coordinateText.addEventListener('pointerup', () => {
          const yaw = Number(viewer.getYaw().toFixed(3));
          const pitch = Number(viewer.getPitch().toFixed(3));
          const text = prompt(
            `(${yaw.toFixed(2)},${pitch.toFixed(2)}) にマーカーを追加する`,
            '',
          );
          setMarker({ pitch, yaw, text });
        });
        const coordinateDiv = dom('div', { class: 'coordinate' }, function* () {
          yield* createMarker(coordinateText);
          yield coordinateText;
        });
        let timerId = requestAnimationFrame(() => {});
        const track = () => {
          cancelAnimationFrame(timerId);
          let lastChangedAt = Infinity;
          let previousYaw = Infinity;
          let previousPitch = Infinity;
          /** @param {number} timeStamp */
          const onRendering = (timeStamp) => {
            timerId = requestAnimationFrame(onRendering);
            const yaw = viewer.getYaw();
            const pitch = viewer.getPitch();
            if (yaw === previousYaw && pitch === previousPitch) {
              if (100 < timeStamp - lastChangedAt) {
                cancelAnimationFrame(timerId);
              }
            } else {
              sync();
              previousYaw = yaw;
              previousPitch = pitch;
              lastChangedAt = timeStamp;
            }
          };
          timerId = requestAnimationFrame(onRendering);
        };
        const watch = () => {
          cancelAnimationFrame(timerId);
          const onRendering = () => {
            timerId = requestAnimationFrame(onRendering);
            sync();
          };
          onRendering();
        };
        const enable = () => {
          track();
          const container = viewer.getContainer();
          if (!container.contains(coordinateDiv)) {
            container.append(coordinateDiv);
            viewer.on('mousedown', watch);
            viewer.on('mouseup', track);
            viewer.on('touchstart', watch);
            viewer.on('touchend', track);
            viewer.on('animatefinished', sync);
          }
        };
        const disable = () => {
          const container = viewer.getContainer();
          if (container.contains(coordinateDiv)) {
            coordinateDiv.remove();
            viewer.off('mousedown', watch);
            viewer.off('mouseup', track);
            viewer.off('touchstart', watch);
            viewer.off('touchend', track);
            viewer.off('animatefinished', sync);
          }
        };
        return { enable, disable, track };
      })();
      for (const [name, value] of Object.entries(config)) {
        switch (name) {
          case 'title':
            document.title = value;
            break;
          case 'hotSpots': {
            value.forEach((marker, index) => {
              marker.id = marker.id || `hs-${index + 1}`;
              marker.createTooltipFunc = createTooltip;
              marker.createTooltipArgs = marker;
            });
            if (location.hash.startsWith('#')) {
              const targetId = location.hash.slice(1);
              for (const marker of value) {
                if (marker.id === targetId) {
                  config.pitch = marker.pitch;
                  config.yaw = marker.yaw;
                  break;
                }
              }
            }
            break;
          }
          default:
        }
      }
      viewer = pannellum.viewer('container', config);
      const isLocalFile = config.panorama.startsWith('blob:');
      const container = viewer.getContainer();
      /** @param {{id: string, name: string, checked: boolean, disabled?: boolean, handler: (checked: boolean) => void}} props */
      const generateToggle = function* ({
        name,
        id,
        checked,
        disabled,
        handler,
      }) {
        /** @type {HTMLInputElement} */
        const input = dom('input', { id, type: 'checkbox', checked, disabled });
        const label = dom('label', { for: input.id }, name);
        const onChange = () => handler(input.checked);
        setTimeout(onChange);
        input.addEventListener('change', onChange);
        yield input;
        yield label;
      };
      container.append(
        dom(
          'div',
          { class: 'app-settings' },
          dom(
            'section',
            { class: 'app-options' },
            dom('h1', null, 'マーカー（クリックで移動）'),
            dom('dl', { class: 'marker-list' }),
            dom('hr'),
            ...generateToggle({
              id: 'show-markers',
              name: 'マーカーを表示 (m)',
              checked: true,
              handler: (checked) => {
                container.dataset.showMarkers = Number(checked);
              },
            }),
            ...generateToggle({
              id: 'vertical-markers',
              name: 'マーカーを縦書き表示 (v)',
              checked: true,
              handler: (checked) => {
                container.dataset.verticalMarkers = Number(checked);
              },
            }),
            ...generateToggle({
              id: 'show-coordinate',
              name: '画面中心の座標を表示 (p)',
              checked: false,
              handler: (checked) => {
                if (checked) {
                  coordinateMonitor.enable();
                } else {
                  coordinateMonitor.disable();
                }
              },
            }),
            function* () {
              const fullscreenIsSupported =
                'fullscreenElement' in document ||
                'webkitFullscreenElement' in document;
              const gen = generateToggle({
                id: 'toggle-fullscreen',
                name: 'フルスクリーンで表示 (f)',
                checked: false,
                disabled: !fullscreenIsSupported,
                handler: () => viewer.toggleFullscreen(),
              });
              const input = gen.next().value;
              if (input) {
                viewer.on('fullscreenchange', (active) => {
                  input.checked = active;
                });
                yield input;
              }
              yield* gen;
            },
            function* () {
              const gen = generateToggle({
                id: 'toggle-orientation',
                name: '加速度センサーで操作',
                checked: viewer.isOrientationActive(),
                disabled: !viewer.isOrientationSupported(),
                handler: (checked) => {
                  if (checked) {
                    viewer.startOrientation();
                  } else {
                    viewer.stopOrientation();
                  }
                },
              });
              const input = gen.next().value;
              if (input) {
                viewer.on('orientationmode', (active) => {
                  input.checked = active;
                });
                yield input;
              }
              yield* gen;
            },
            dom('hr'),
            dom('a', { id: 'export-json' }, 'マーカー情報をダウンロード'),
            dom('hr'),
            dom('div', { class: 'zoom-slider' }, function* () {
              const d = 0.1;
              const viewBox = '-6.5 -6.5 13 13';
              const zoomOut = dom(
                'svg',
                { title: '縮小', viewBox },
                dom('circle', { cx: 0, cy: 0, r: 5 }),
                dom('path', { d: 'M-3 0H3' }),
              );
              const zoomIn = dom(
                'svg',
                { title: '拡大', viewBox },
                dom('circle', { cx: 0, cy: 0, r: 5 }),
                dom('path', { d: 'M-3 0H3M0 -3V3' }),
              );
              const range = dom('input', {
                type: 'range',
                min: 0,
                max: 1,
                step: 0.004,
              });
              /** @param {number} hfov */
              const syncZoom = (hfov) => {
                const [min, max] = viewer.getHfovBounds();
                range.value = 1 - Math.log(hfov / min) / Math.log(max / min);
              };
              syncZoom();
              yield zoomOut;
              yield range;
              yield zoomIn;
              /**
               * @param {number|string} z in [0,1]
               * @param {number} a
               */
              const setZoom = (z, a = 200) => {
                z = range.value = Math.max(0, Math.min(1, Number(z)));
                const [min, max] = viewer.getHfovBounds();
                const hfov = min * (max / min) ** (1 - z);
                viewer.lookAt(undefined, undefined, hfov, a);
              };
              const setZoomDiff = (d) => setZoom(Number(range.value) + d);
              range.addEventListener('input', () => setZoom(range.value, 0));
              zoomOut.addEventListener('click', (event) => {
                event.preventDefault();
                setZoomDiff(-d);
              });
              zoomIn.addEventListener('click', (event) => {
                event.preventDefault();
                setZoomDiff(d);
              });
              viewer.on('zoomchange', syncZoom);
            }),
            dom('hr'),
          ),
          function* (options) {
            const toggle = dom(
              'button',
              { id: 'config-toggle', class: 'toggle' },
              '',
            );
            toggle.addEventListener('click', () => {
              options.classList.toggle('active');
            });
            yield toggle;
          },
        ),
      );
      /** @param {{key: string}} event */
      const onKeyDown = (event) => {
        switch (event.key) {
          case '?':
            container.querySelector('#config-toggle')?.click();
            break;
          case 'f':
            container.querySelector('#toggle-fullscreen')?.click();
            break;
          case 'p':
            container.querySelector('#show-coordinate')?.click();
            break;
          case 'm':
            container.querySelector('#show-markers')?.click();
            break;
          case 'v':
            container.querySelector('#vertical-markers')?.click();
            break;
          case '0':
            viewer.setYaw(0);
            viewer.setPitch(0);
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9': {
            const marker = getMarkers()[Number(event.key) - 1];
            if (marker) {
              focusMarker(marker.id);
            }
            break;
          }
          default:
        }
      };
      addEventListener('keydown', onKeyDown);
      addEventListener('dragover', (event) => event.preventDefault());
      addEventListener('drop', (event) => {
        event.preventDefault();
        let imageFile;
        let jsonPromise = Promise.resolve();
        for (const file of event.dataTransfer.files) {
          if (file.type.startsWith('image/')) {
            imageFile = file;
          } else if (file.type.endsWith('/json')) {
            jsonPromise = new Promise((resolve) => {
              const reader = new FileReader();
              reader.readAsText(file);
              reader.onload = () => resolve(JSON.parse(reader.result));
            });
          }
        }
        jsonPromise
          .then((newConfig) => {
            if (newConfig) {
              newConfig = { ...config, ...newConfig };
            } else {
              newConfig = { ...config };
              if (imageFile) {
                newConfig.hotSpots = [];
                newConfig.author = 'No Name';
                newConfig.title = imageFile.name;
              }
            }
            if (imageFile) {
              newConfig.panorama = URL.createObjectURL(imageFile);
              start(newConfig);
            } else {
              for (const marker of getMarkers()) {
                viewer.removeHotSpot(marker.id);
              }
              for (const marker of newConfig.hotSpots.slice()) {
                setMarker(marker);
              }
            }
          })
          .catch((error) => {
            console.error(error);
            alert(`${error}`);
          });
      });
      syncMarkersList();
      if (isLocalFile) {
        container.querySelector('#show-coordinate')?.click();
      }
    };
    start(await loadConfig());
  })().catch((error) => {
    console.error(error);
    alert(`${error}`);
  });
</script>
