<!DOCTYPE html> <meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>360度パノラマ画像ライブラリ</title>
<link rel="stylesheet" href="pannellum.css" />
<script>
  if (!('DeviceMotionEvent' in globalThis)) {
    globalThis.DeviceMotionEvent = {};
  }
</script>
<style>
  * {
    margin: 0;
    padding: 0;
    font: inherit;
    color: inherit;
    appearance: none;
    background-color: transparent;
    background-repeat: no-repeat;
    background-position: center;
    border-style: none;
    border-color: currentColor;
    border-width: 1px;
    border-radius: 0;
    stroke-linejoin: round;
    stroke-linecap: round;
    stroke-width: 1px;
    fill: none;
  }
  button {
    cursor: pointer;
  }
  :root {
    --footer-baseline: 6px;
    --border-radius: 5px;
    --ui-background: rgba(0, 0, 0, 0.4);
    --font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN',
      'Hiragino Sans', 'BIZ UDPGothic', Meiryo, sans-serif;
    height: 100%;
  }
  body {
    position: fixed;
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: var(--font-family);
    font-size: 14px;
  }
  .pnlm-container {
    font-family: var(--font-family);
  }
  .pnlm-container[data-show-markers='0'] .pnlm-hotspot {
    opacity: 0;
    pointer-events: none;
  }
  .pnlm-hotspot {
    display: grid;
    align-content: center;
    justify-content: center;
    cursor: pointer;
  }
  .pnlm-title-box {
    font-size: inherit;
    margin-bottom: 0;
  }
  .pnlm-container[data-vertical-markers='1'] .hotspot-tooltip {
    writing-mode: vertical-rl;
  }
  .hotspot-tooltip {
    position: absolute;
    bottom: 50%;
    left: 50%;
    transform: translateX(-50%);
    inline-size: max-content;
    max-inline-size: 183px;
    padding-inline: 6px;
    padding-block: 2px;
    color: #ffffff;
  }
  .hotspot-marker {
    position: absolute;
    filter: drop-shadow(0 0 2px #000000);
  }
  .hotspot-marker > path {
    /* fill: var(--ui-background); */
    fill: currentColor;
    stroke: currentColor;
    pointer-events: none;
  }
  .pnlm-hotspot > .hotspot-marker {
    bottom: 50%;
    left: 50%;
    transform: translateX(-50%);
  }
  .hotspot-marker-backdrop {
    display: none;
    position: absolute;
  }
  .hotspot-marker-backdrop,
  .pnlm-panorama-info,
  .app-settings {
    backdrop-filter: blur(2px);
  }
  .coordinate-text,
  .hotspot-tooltip,
  .pnlm-panorama-info,
  .app-settings {
    text-shadow: 0 0 4px #000000;
  }
  .coordinate {
    z-index: 1;
    position: absolute;
    left: 50%;
    bottom: 50%;
    transform: translateX(-50%);
    display: grid;
    grid-auto-flow: row;
    row-gap: 2px;
    justify-items: center;
  }
  .coordinate > .hotspot-marker {
    bottom: 0;
  }
  .coordinate > button {
    position: absolute;
    bottom: 0;
    padding: 2px 6px;
    background: none;
    border: none;
    color: inherit;
    font: inherit;
    cursor: pointer;
    white-space: nowrap;
  }
  .pnlm-panorama-info,
  .app-settings,
  .pnlm-hotspot,
  .coordinate {
    color: #ffffff;
    font-size: inherit;
    font-weight: 600;
  }
  .pnlm-panorama-info,
  .app-settings {
    --gap: 4px;
    --padding-v: 8px;
    --padding-h: 11px;
    bottom: var(--footer-baseline);
    padding: var(--padding-v) var(--padding-h);
    /* border-style: solid; */
    background-color: var(--ui-background);
  }
  .pnlm-panorama-info {
    display: grid;
    grid-auto-flow: row;
    align-items: end;
    border-radius: 0 var(--border-radius) var(--border-radius) 0;
    border-left-width: 0;
  }
  .pnlm-panorama-info > * {
    padding: 0;
  }
  .app-settings {
    z-index: 1;
    position: absolute;
    right: 0;
    display: grid;
    grid-auto-flow: row;
    justify-content: end;
    justify-items: end;
    row-gap: var(--gap);
    max-width: 90%;
    border-radius: var(--border-radius) 0 0 var(--border-radius);
    border-right-width: 0;
  }
  .app-settings > #config-toggle {
    padding: var(--padding-v) var(--padding-h);
    margin: calc(-1 * var(--padding-v)) calc(-1 * var(--padding-h));
  }
  .app-options {
    display: grid;
    grid-template-columns: max-content 1fr;
    align-items: center;
    column-gap: var(--gap);
    row-gap: var(--gap);
    padding-block: var(--gap);
  }
  .app-settings > #config-toggle::before {
    content: '設定';
  }
  .app-settings.active > #config-toggle::before {
    content: '閉じる';
  }
  .app-settings.active + .pnlm-panorama-info {
    display: none;
  }
  .app-settings:not(.active) > section {
    display: none;
  }
  .app-options > input {
    appearance: auto;
  }
  .app-options > input:disabled,
  .app-options > input:disabled + label {
    opacity: 0.7;
    pointer-events: none;
  }
  .app-options > input:disabled + label {
    text-decoration: line-through;
  }
  .app-options > h1,
  .app-options > hr,
  .app-options > .zoom-slider {
    grid-column: 1 / 3;
  }
  .app-options > hr {
    margin-block: var(--gap);
    block-size: 1px;
    background-color: currentColor;
    opacity: 0.5;
  }
  .zoom-slider {
    display: grid;
    grid-template-columns: max-content 1fr max-content;
    align-items: center;
    column-gap: 6px;
    padding: 4px 0;
  }
  .zoom-slider > input {
    background-image: linear-gradient(currentColor, currentColor);
    background-size: 100% 1px;
  }
  .zoom-slider > svg {
    width: 16px;
    height: 16px;
    cursor: pointer;
  }
  .zoom-slider > svg > * {
    stroke: currentColor;
    stroke-width: 1.5px;
  }
  .marker-list {
    grid-column: 1 / 3;
    display: grid;
    grid-template-columns: max-content 1fr;
    row-gap: var(--gap);
    column-gap: var(--gap);
  }
  .marker-list > dd {
    max-inline-size: 20em;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    cursor: pointer;
  }
  .marker-list > dd:hover {
    text-decoration: underline;
  }
</style>
<div id="container">
  <noscript>
    <div class="pnlm-info-box">
      <p>パノラマ画像を表示にはJavaScriptを有効にしてください。</p>
      <p>Javascript is required to view this panorama.</p>
    </div>
  </noscript>
</div>
<script src="pannellum.js"></script>
<script>
  //@ts-check
  (async function () {
    const SVGNS = 'http://www.w3.org/2000/svg';
    const createElement = (tagName) => {
      switch (tagName) {
        case 'svg':
        case 'path':
        case 'circle':
        case 'rect':
          return document.createElementNS(SVGNS, tagName);
        default:
          return document.createElement(tagName);
      }
    };
    /** @typedef {Record<string, string | boolean>} Attrs */
    /** @typedef {[string, Attrs, Array<NodeDef | string>]} NodeDef */
    /**
     * @template {HTMLElement} T
     * @typedef {(parent: T) => Iterable<Node>} NodeGen
     */
    /**
     * @template {string} T
     * @template {HTMLElement} S
     * @param {T} tagName
     * @param {Attrs | null} attrs
     * @param {Array<NodeGen<S> | Node | string>} children
     * @returns {S}
     */
    const dom = (tagName, attrs = {}, ...children) => {
      const node = createElement(tagName);
      if (attrs) {
        for (const [name, value] of Object.entries(attrs)) {
          switch (name) {
            case 'checked':
            case 'disabled':
            case 'selected':
              node[name] = value;
              break;
            default:
              if (value || typeof value === 'number') {
                node.setAttribute(name, `${value}`);
              }
          }
        }
      }
      if (children) {
        for (const child of children) {
          if (typeof child === 'function') {
            node.append(...child(node));
          } else if (typeof child === 'string') {
            node.append(document.createTextNode(child));
          } else if (child instanceof Node) {
            node.append(child);
          }
        }
      }
      return node;
    };
    const createMarker = function* (wrappee) {
      const backdrop = dom('div', { class: 'hotspot-marker-backdrop' });
      yield backdrop;
      yield dom('svg', { class: 'hotspot-marker' }, function* (svg) {
        const lw = 1;
        const aw2 = 4;
        const ah = 6;
        const r = 4;
        const path = dom('path', { style: `stroke-width:${lw}px` });
        const observer = new ResizeObserver(([{ target }]) => {
          const rect = target.getBoundingClientRect();
          const pRect = target.parentElement?.getBoundingClientRect();
          if (pRect) {
            Object.assign(backdrop.style, {
              left: `${rect.left - pRect.left}px`,
              top: `${rect.top - pRect.top}px`,
              width: `${rect.width}px`,
              height: `${rect.height}px`,
            });
          }
          const w2 = rect.width / 2;
          const h = rect.height;
          {
            const ww = w2 * 2 + lw * 2;
            const hh = h + ah + lw * 2;
            svg.style.width = `${ww}px`;
            svg.style.height = `${hh}px`;
            const viewBox = `${ww / -2} ${-hh + ah + lw} ${ww} ${hh}`;
            svg.setAttribute('viewBox', viewBox);
          }
          const d = `M${-aw2} 0L0 ${ah}L${aw2} 0Z`;
          // let d = `M${-aw2} 0L0 ${ah}L${aw2} 0H${w2 - r}q${r} 0 ${r} ${-r}`;
          // d += `V${-h + r}q0 ${-r} ${-r} ${-r}H${-w2 + r}`;
          // d += `q${-r} 0 ${-r} ${r}V${-r}q0 ${r} ${r} ${r}Z`;
          path.setAttribute('d', d);
        });
        observer.observe(wrappee);
        wrappee.style.marginBottom = `${ah + lw / 2}px`;
        yield path;
      });
    };
    const loadConfig = async () => {
      const image = new URLSearchParams(location.search).get('image');
      const params = { panorama: `${image}.jpg`, config: `${image}.json` };
      const res = await fetch(params.config);
      if (!res.ok) {
        throw new Error(`The file ${params.config} could not be accessed.`);
      }
      const merged = {
        ...params,
        ...(await res.json()),
        autoLoad: true,
        keyboardZoom: false,
        showControls: false,
        friction: 0.8,
      };
      for (const [name, value] of Object.entries(merged)) {
        switch (name) {
          case 'title':
            document.title = value;
            break;
          case 'hotSpots': {
            const createTooltip = (markerDiv, marker) => {
              markerDiv.dataset.hotspot = marker.id;
              markerDiv.style.backgroundImage = 'none';
              const tooltip = dom(
                'div',
                { class: 'hotspot-tooltip' },
                marker.text,
              );
              markerDiv.append(...createMarker(tooltip), tooltip);
              markerDiv.addEventListener('click', (event) => {
                focusMarker(marker.id);
              });
            };
            value.forEach((marker, index) => {
              marker.id = marker.id || `hs-${index + 1}`;
              marker.createTooltipFunc = createTooltip;
              marker.createTooltipArgs = marker;
            });
            if (location.hash.startsWith('#')) {
              const targetId = location.hash.slice(1);
              for (const marker of value) {
                if (marker.id === targetId) {
                  merged.pitch = marker.pitch;
                  merged.yaw = marker.yaw;
                  break;
                }
              }
            }
            break;
          }
          default:
        }
      }
      return merged;
    };
    const config = await loadConfig();
    // @ts-ignore
    const viewer = pannellum.viewer('container', config);
    const getMarkers = () => viewer.getConfig().hotSpots || [];
    const container = viewer.getContainer();
    const coordinateMonitor = (function () {
      const coordinateText = dom('button', {
        title: 'クリックでコピー',
        class: 'coordinate-text',
      });
      const sync = () => {
        const yaw = viewer.getYaw().toFixed(2);
        const pitch = viewer.getPitch().toFixed(2);
        coordinateText.textContent = `${yaw}, ${pitch}`;
      };
      coordinateText.addEventListener('pointerup', () => {
        const text = JSON.stringify({
          yaw: Number(viewer.getYaw().toFixed(3)),
          pitch: Number(viewer.getPitch().toFixed(3)),
          text: 'タイトル',
        });
        navigator.clipboard.writeText(text).then(() => {
          coordinateText.textContent = 'コピーしました';
          setTimeout(sync, 800);
        });
      });
      const coordinateDiv = dom('div', { class: 'coordinate' }, function* () {
        yield* createMarker(coordinateText);
        yield coordinateText;
      });
      let timerId = requestAnimationFrame(() => {});
      const track = () => {
        cancelAnimationFrame(timerId);
        let lastChangedAt = Infinity;
        let previousYaw = Infinity;
        let previousPitch = Infinity;
        /** @param {number} timeStamp */
        const onRendering = (timeStamp) => {
          timerId = requestAnimationFrame(onRendering);
          const yaw = viewer.getYaw();
          const pitch = viewer.getPitch();
          if (yaw === previousYaw && pitch === previousPitch) {
            if (100 < timeStamp - lastChangedAt) {
              cancelAnimationFrame(timerId);
            }
          } else {
            sync();
            previousYaw = yaw;
            previousPitch = pitch;
            lastChangedAt = timeStamp;
          }
        };
        timerId = requestAnimationFrame(onRendering);
      };
      const watch = () => {
        cancelAnimationFrame(timerId);
        const onRendering = () => {
          timerId = requestAnimationFrame(onRendering);
          sync();
        };
        onRendering();
      };
      const enable = () => {
        track();
        if (!container.contains(coordinateDiv)) {
          container.append(coordinateDiv);
          viewer.on('mousedown', watch);
          viewer.on('mouseup', track);
          viewer.on('touchstart', watch);
          viewer.on('touchend', track);
          viewer.on('animatefinished', sync);
        }
      };
      const disable = () => {
        if (container.contains(coordinateDiv)) {
          coordinateDiv.remove();
          viewer.off('mousedown', watch);
          viewer.off('mouseup', track);
          viewer.off('touchstart', watch);
          viewer.off('touchend', track);
          viewer.off('animatefinished', sync);
        }
      };
      return { enable, disable, track };
    })();
    /** @param {string} id */
    const focusMarker = (id) => {
      const marker = getMarkers().find((marker) => marker.id === id);
      if (marker) {
        location.hash = `#${marker.id}`;
        viewer.setYaw(marker.yaw);
        viewer.setPitch(marker.pitch);
        coordinateMonitor.track();
      }
    };
    /** @param {{id: string, name: string, checked: boolean, disabled?: boolean, handler: (checked: boolean) => void}} props */
    const generateToggle = function* ({
      name,
      id,
      checked,
      disabled,
      handler,
    }) {
      /** @type {HTMLInputElement} */
      const input = dom('input', { id, type: 'checkbox', checked, disabled });
      const label = dom('label', { for: input.id }, name);
      const onChange = () => handler(input.checked);
      setTimeout(onChange);
      input.addEventListener('change', onChange);
      yield input;
      yield label;
    };
    container.querySelector('.pnlm-panorama-info').before(
      dom(
        'div',
        { class: 'app-settings' },
        dom(
          'section',
          { class: 'app-options' },
          dom('h1', null, 'マーカー（クリックで移動）'),
          function* () {
            const markersList = dom('dl', { class: 'marker-list' });
            getMarkers().forEach((marker, index) => {
              const dd = dom('dd', null, marker.text);
              dd.addEventListener('click', () => focusMarker(marker.id));
              markersList.append(dom('dt', null, `(${index + 1})`), dd);
            });
            yield markersList;
          },
          dom('hr'),
          ...generateToggle({
            id: 'show-markers',
            name: 'マーカーを表示 (m)',
            checked: true,
            handler: (checked) => {
              container.dataset.showMarkers = Number(checked);
            },
          }),
          ...generateToggle({
            id: 'vertical-markers',
            name: 'マーカーを縦書き表示 (v)',
            checked: true,
            handler: (checked) => {
              container.dataset.verticalMarkers = Number(checked);
            },
          }),
          ...generateToggle({
            id: 'show-coordinate',
            name: '画面中心の座標を表示 (p)',
            checked: false,
            handler: (checked) => {
              if (checked) {
                coordinateMonitor.enable();
              } else {
                coordinateMonitor.disable();
              }
            },
          }),
          function* () {
            const fullscreenIsSupported =
              'fullscreenElement' in document ||
              'webkitFullscreenElement' in document;
            const gen = generateToggle({
              id: 'toggle-fullscreen',
              name: 'フルスクリーンで表示 (f)',
              checked: false,
              disabled: !fullscreenIsSupported,
              handler: () => viewer.toggleFullscreen(),
            });
            const input = gen.next().value;
            if (input) {
              viewer.on('fullscreenchange', (active) => {
                input.checked = active;
              });
              yield input;
            }
            yield* gen;
          },
          function* () {
            const gen = generateToggle({
              id: 'toggle-orientation',
              name: '加速度センサーで操作',
              checked: viewer.isOrientationActive(),
              disabled: !viewer.isOrientationSupported(),
              handler: (checked) => {
                if (checked) {
                  viewer.startOrientation();
                } else {
                  viewer.stopOrientation();
                }
              },
            });
            const input = gen.next().value;
            if (input) {
              viewer.on('orientationmode', (active) => {
                input.checked = active;
              });
              yield input;
            }
            yield* gen;
          },
          dom('hr'),
          dom('div', { class: 'zoom-slider' }, function* () {
            const d = 0.1;
            const viewBox = '-6.5 -6.5 13 13';
            const zoomOut = dom(
              'svg',
              { title: '縮小', viewBox },
              dom('circle', { cx: 0, cy: 0, r: 5 }),
              dom('path', { d: 'M-3 0H3' }),
            );
            const zoomIn = dom(
              'svg',
              { title: '拡大', viewBox },
              dom('circle', { cx: 0, cy: 0, r: 5 }),
              dom('path', { d: 'M-3 0H3M0 -3V3' }),
            );
            const range = dom('input', {
              type: 'range',
              min: 0,
              max: 1,
              step: 0.004,
            });
            /** @param {number} hfov */
            const syncZoom = (hfov) => {
              const [min, max] = viewer.getHfovBounds();
              range.value = 1 - Math.log(hfov / min) / Math.log(max / min);
            };
            syncZoom();
            yield zoomOut;
            yield range;
            yield zoomIn;
            /**
             * @param {number|string} z in [0,1]
             * @param {number} a
             */
            const setZoom = (z, a = 200) => {
              z = range.value = Math.max(0, Math.min(1, Number(z)));
              const [min, max] = viewer.getHfovBounds();
              const hfov = min * (max / min) ** (1 - z);
              viewer.lookAt(undefined, undefined, hfov, a);
            };
            const setZoomDiff = (d) => setZoom(Number(range.value) + d);
            range.addEventListener('input', () => setZoom(range.value, 0));
            zoomOut.addEventListener('click', (event) => {
              event.preventDefault();
              setZoomDiff(-d);
            });
            zoomIn.addEventListener('click', (event) => {
              event.preventDefault();
              setZoomDiff(d);
            });
            viewer.on('zoomchange', syncZoom);
          }),
          dom('hr'),
        ),
        function* (options) {
          const toggle = dom(
            'button',
            { id: 'config-toggle', class: 'toggle' },
            ' (?)',
          );
          toggle.addEventListener('click', () => {
            options.classList.toggle('active');
          });
          yield toggle;
        },
      ),
    );
    /** @param {{key: string}} event */
    const onKeyDown = (event) => {
      switch (event.key) {
        case '?':
          container.querySelector('#config-toggle')?.click();
          break;
        case 'f':
          container.querySelector('#toggle-fullscreen')?.click();
          break;
        case 'p':
          container.querySelector('#show-coordinate')?.click();
          break;
        case 'm':
          container.querySelector('#show-markers')?.click();
          break;
        case 'v':
          container.querySelector('#vertical-markers')?.click();
          break;
        case '0':
          viewer.setYaw(0);
          viewer.setPitch(0);
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9': {
          const marker = getMarkers()[Number(event.key) - 1];
          if (marker) {
            focusMarker(marker.id);
          }
          break;
        }
        default:
      }
    };
    addEventListener('keydown', onKeyDown);
  })().catch((error) => alert(`${error}`));
</script>
